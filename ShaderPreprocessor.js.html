<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ShaderPreprocessor.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ColorTexture2D.html">ColorTexture2D</a><ul class='methods'><li data-type='method'><a href="ColorTexture2D.html#bind">bind</a></li><li data-type='method'><a href="ColorTexture2D.html#bufferData">bufferData</a></li><li data-type='method'><a href="ColorTexture2D.html#bufferSubData">bufferSubData</a></li><li data-type='method'><a href="ColorTexture2D.html#resize">resize</a></li><li data-type='method'><a href="ColorTexture2D.html#setParameters">setParameters</a></li><li data-type='method'><a href="ColorTexture2D.html#unbind">unbind</a></li></ul></li><li><a href="DepthTexture2D.html">DepthTexture2D</a><ul class='methods'><li data-type='method'><a href="DepthTexture2D.html#bind">bind</a></li><li data-type='method'><a href="DepthTexture2D.html#bufferData">bufferData</a></li><li data-type='method'><a href="DepthTexture2D.html#bufferSubData">bufferSubData</a></li><li data-type='method'><a href="DepthTexture2D.html#resize">resize</a></li><li data-type='method'><a href="DepthTexture2D.html#setParameters">setParameters</a></li><li data-type='method'><a href="DepthTexture2D.html#unbind">unbind</a></li></ul></li><li><a href="IndexBuffer.html">IndexBuffer</a><ul class='methods'><li data-type='method'><a href="IndexBuffer.html#bufferData">bufferData</a></li><li data-type='method'><a href="IndexBuffer.html#bufferSubData">bufferSubData</a></li><li data-type='method'><a href="IndexBuffer.html#draw">draw</a></li></ul></li><li><a href="Renderable.html">Renderable</a><ul class='methods'><li data-type='method'><a href="Renderable.html#draw">draw</a></li></ul></li><li><a href="RenderTarget.html">RenderTarget</a><ul class='methods'><li data-type='method'><a href="RenderTarget.html#bind">bind</a></li><li data-type='method'><a href="RenderTarget.html#resize">resize</a></li><li data-type='method'><a href="RenderTarget.html#setColorTarget">setColorTarget</a></li><li data-type='method'><a href="RenderTarget.html#setDepthTarget">setDepthTarget</a></li><li data-type='method'><a href="RenderTarget.html#unbind">unbind</a></li></ul></li><li><a href="Shader.html">Shader</a><ul class='methods'><li data-type='method'><a href="Shader.html#setUniform">setUniform</a></li><li data-type='method'><a href="Shader.html#setUniforms">setUniforms</a></li><li data-type='method'><a href="Shader.html#use">use</a></li></ul></li><li><a href="Texture2D.html">Texture2D</a><ul class='methods'><li data-type='method'><a href="Texture2D.html#bind">bind</a></li><li data-type='method'><a href="Texture2D.html#bufferData">bufferData</a></li><li data-type='method'><a href="Texture2D.html#bufferSubData">bufferSubData</a></li><li data-type='method'><a href="Texture2D.html#resize">resize</a></li><li data-type='method'><a href="Texture2D.html#setParameters">setParameters</a></li><li data-type='method'><a href="Texture2D.html#unbind">unbind</a></li></ul></li><li><a href="TextureCubeMap.html">TextureCubeMap</a><ul class='methods'><li data-type='method'><a href="TextureCubeMap.html#bind">bind</a></li><li data-type='method'><a href="TextureCubeMap.html#bufferData">bufferData</a></li><li data-type='method'><a href="TextureCubeMap.html#setParameters">setParameters</a></li><li data-type='method'><a href="TextureCubeMap.html#unbind">unbind</a></li></ul></li><li><a href="VertexBuffer.html">VertexBuffer</a><ul class='methods'><li data-type='method'><a href="VertexBuffer.html#bind">bind</a></li><li data-type='method'><a href="VertexBuffer.html#bufferData">bufferData</a></li><li data-type='method'><a href="VertexBuffer.html#bufferSubData">bufferSubData</a></li><li data-type='method'><a href="VertexBuffer.html#draw">draw</a></li><li data-type='method'><a href="VertexBuffer.html#unbind">unbind</a></li></ul></li><li><a href="VertexPackage.html">VertexPackage</a><ul class='methods'><li data-type='method'><a href="VertexPackage.html#set">set</a></li></ul></li><li><a href="Viewport.html">Viewport</a><ul class='methods'><li data-type='method'><a href="Viewport.html#pop">pop</a></li><li data-type='method'><a href="Viewport.html#push">push</a></li><li data-type='method'><a href="Viewport.html#resize">resize</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">ShaderPreprocessor.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const DEFINED = '__DEFINED__';

const DEFINE_REGEX = /#define\b/i;
const UNDEF_REGEX = /#undef\b/i;
const IF_REGEX = /#if\b/i;
const IFDEF_REGEX = /#ifdef\b/i;
const IFNDEF_REGEX = /#ifndef\b/i;
const ELSE_REGEX = /#else\b/i;
const ELIF_REGEX = /#elif\b/i;
const ENDIF_REGEX = /#endif\b/i;

const PARSE_DEFINE_REGEX = /#define\s+(\w+)(\s(\w*)?)?/i;
const PARSE_UNDEF_REGEX = /#undef\s+(\w+)/i;
const PARSE_IF_REGEX = /#if\s+\(?\s*(!?\s*\w+)\s*(==|!=|>=|&lt;=|&lt;|&lt;|>)?\s*(\w*)\s*\)?/i;
const PARSE_IFDEF_REGEX = /#ifdef\s+(\w+)/i;
const PARSE_IFNDEF_REGEX = /#ifndef\s+(\w+)/i;
const PARSE_ELIF_REGEX = /#elif\s+\(?\s*(!?\s*\w+)\s*(==|!=|>=|&lt;=|&lt;|&lt;|>)?\s*(\w*)\s*\)?/i;
const REMAINING_REGEX = /#([\W\w\s\d])(?:.*\\r?\n)*.*$/gm;

const evalIf = function(a, logic, b) {
	if (logic === undefined) {
		if (a[0] === '!') {
			return !(a === 'true' || a >= 1);
		}
		return a === 'true' || a >= 1;
	}
	switch (logic) {
		case '==':
			return a === b;
		case '!=':
			return a !== b;
		case '>':
			return a > b;
		case '>=':
			return a >= b;
		case '&lt;':
			return a &lt; b;
		case '&lt;=':
			return a &lt;= b;
	}
	throw `Unrecognized logical operator \`${logic}\``;
};

class Conditional {
	constructor(type, conditional) {
		this.type = type;
		this.conditional = conditional.trim();
		this.body = [];
		this.children = [];
	}
	eval() {
		let parsed;
		switch (this.type) {
			case 'if':
				parsed = PARSE_IF_REGEX.exec(this.conditional);
				return evalIf(parsed[1], parsed[2], parsed[3]);
			case 'ifdef':
				parsed = PARSE_IFDEF_REGEX.exec(this.conditional);
				return parsed[1] === DEFINED;
			case 'ifndef':
				parsed = PARSE_IFNDEF_REGEX.exec(this.conditional);
				return parsed[1] !== DEFINED;
			case 'elif':
				parsed = PARSE_ELIF_REGEX.exec(this.conditional);
				return evalIf(parsed[1], parsed[2], parsed[3]);
		}
		throw `Unrecognized conditional type \`${this.type}\``;
	}
}

class Block {
	constructor(type, conditional, lineNum) {
		this.if = new Conditional(type, conditional);
		this.elif = [];
		this.else = null;
		this.parent = null;
		this.current = this.if;
		this.startLine = lineNum;
		this.endLine = null;
	}
	addElse(conditional) {
		this.current = new Conditional('else', conditional);
		this.else = this.current;
	}
	addElif(conditional) {
		this.current = new Conditional('elif', conditional);
		this.elif.push(this.current);
	}
	addBody(line, lineNum) {
		this.current.body.push({
			string: line.trim(),
			line: lineNum
		});
	}
	nest(block) {
		block.parent = this;
		this.current.children.push(block);
	}
	extract() {
		// #if
		let body = [];
		if (this.if.eval()) {
			body = body.concat(this.if.body);
			this.if.children.forEach(child => {
				body = body.concat(child.extract());
			});
			return body;
		}
		// #elif
		for (let i=0; i&lt;this.elif.length; i++) {
			const elif = this.elif[i];
			if (elif.eval()) {
				body = body.concat(elif.body);
				for (let j=0; j&lt;elif.children.length; j++) {
					const child = elif.children[j];
					body = body.concat(child.extract());
				}
				return body;
			}
		}
		// #else
		if (this.else) {
			body = body.concat(this.else.body);
			this.else.children.forEach(child => {
				body = body.concat(child.extract());
			});
			return body;
		}
		return [];
	}
	eval() {
		// ensure extract text is ordered correctly
		return this.extract().sort((a, b) => {
			return a.line - b.line;
		}).map(arg => {
			return arg.string;
		}).join('\n');
	}
}

const parseLines = function(lines) {

	const blocks = [];
	let current = null;

	lines.forEach((line, index) => {

		if (line.match(IF_REGEX)) {
			// #if
			const block = new Block('if', line, index);
			if (!current) {
				blocks.push(block);
			} else {
				current.nest(block);
			}
			current = block;

		} else if (line.match(IFDEF_REGEX)) {
			// #ifdef
			const block = new Block('ifdef', line, index);
			if (!current) {
				blocks.push(block);
			} else {
				current.nest(block);
			}
			current = block;

		} else if (line.match(IFNDEF_REGEX)) {
			// #ifndef
			const block = new Block('ifndef', line, index);
			if (!current) {
				blocks.push(block);
			} else {
				current.nest(block);
			}
			current = block;

		} else if (line.match(ELIF_REGEX)) {
			// #elif
			if (!current) {
				throw 'Invalid preprocessor syntax, unexpected `#elif`';
			}
			current.addElif(line);

		} else if (line.match(ELSE_REGEX)) {
			// #else
			if (!current) {
				throw 'Invalid preprocessor syntax, unexpected `#else`';
			}
			current.addElse(line);

		} else if (line.match(ENDIF_REGEX)) {
			// #endif
			if (!current) {
				throw 'Invalid preprocessor syntax, unexpected `#endif`';
			}
			current.endLine = index;
			current = current.parent;

		} else {
			// other
			if (current) {
				current.addBody(line, index);
			}
		}
	});

	if (current) {
		throw 'Invalid preprocessor syntax, missing expected `#endif`';
	}

	return blocks;
};

const replaceDefines = function(lines) {
	const defines = new Map();
	const replaced = [];
	lines.forEach(line => {
		if (line.match(DEFINE_REGEX)) {
			// #define
			const parsed = PARSE_DEFINE_REGEX.exec(line);
			defines.set(parsed[1], parsed[2] || DEFINED);

		} else if (line.match(UNDEF_REGEX)) {
			// #undef
			const parsed = PARSE_UNDEF_REGEX.exec(line);
			defines.delete(parsed[1]);

		} else if (line.match(IFDEF_REGEX)) {
			// #ifdef
			const parsed = PARSE_IFDEF_REGEX.exec(line);
			if (defines.has(parsed[1])) {
				line = line.replace(parsed[1], DEFINED);
			}
			replaced.push(line);

		} else if (line.match(IFNDEF_REGEX)) {
			// #ifndef
			const parsed = PARSE_IFNDEF_REGEX.exec(line);
			if (defines.has(parsed[1])) {
				line = line.replace(parsed[1], DEFINED);
			}
			replaced.push(line);

		} else {
			// swap defines
			defines.forEach((val, define) => {
				line = line.replace(define, val);
			});
			replaced.push(line);
		}
	});
	return replaced;
};

/**
 * Evaluates GLSL preprocessor statements.
 * NOTE: assumes comments have been stripped, and preprocessors are valid.
 *
 *     Supported:
 *
 *         #define (substitutions only)
 *         #undef
 *         #if (== and != comparisons only)
 *         #ifdef
 *         #ifndef
 *         #elif
 *         #else
 *         #endif
 *
 *     Not Supported:
 *
 *         #define (macros)
 *         #if (&amp;&amp; and || operators, defined() predicate)
 *         #error
 *         #pragma
 *         #extension
 *         #version
 *         #line
 *
 * @param {String} glsl - The glsl source code.
 *
 * @return {String} The processed glsl source code.
 */
module.exports = {
	preprocess: function(glsl) {
		// split lines
		let lines = glsl.split('\n');
		// replace any defines with their values
		lines = replaceDefines(lines);
		// parse them
		const blocks = parseLines(lines);
		// remove blocks in reverse order to preserve line numbers
		for (let i=blocks.length - 1; i>=0; i--) {
			const block = blocks[i];
			const replacement = block.eval();
			if (replacement.length > 0) {
				lines.splice(block.startLine, block.endLine - block.startLine + 1, replacement);
			} else {
				lines.splice(block.startLine, block.endLine - block.startLine + 1);
			}
		}
		// strip remaining unsupported preprocessor statements
		return lines.join('\n').replace(REMAINING_REGEX, '');
	}
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sat Feb 25 2017 17:06:58 GMT-0500 (EST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
